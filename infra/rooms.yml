AWSTemplateFormatVersion: "2010-09-09"
Description: >
  Infrastructure for DALVacationHome application.
  Includes SQS FIFO queue, SNS topic, DynamoDB tables, Lambda functions, and API Gateway.

Resources:
  # SQS Queue
  BookingQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: BookingQueue.fifo
      FifoQueue: true
      ContentBasedDeduplication: true

  # SNS Topic
  BookingNotificationsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: BookingNotifications

  # DynamoDB Tables
  RoomsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: rooms
      AttributeDefinitions:
        - AttributeName: room
          AttributeType: S
      KeySchema:
        - AttributeName: room
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST

  BookingHistoryTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: booking
      AttributeDefinitions:
        - AttributeName: bookingid
          AttributeType: S
      KeySchema:
        - AttributeName: bookingid
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST

  # Lambda Functions
  BookingRequestLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: BookingRequestLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import hashlib
          import uuid

          sqs = boto3.client('sqs')
          QUEUE_URL = os.environ.get('QUEUE_URL', 'https://sqs.us-east-1.amazonaws.com/123456789012/my-queue')

          def lambda_handler(event, context):
              try:
                  if 'body' not in event:
                      raise ValueError("Missing 'body' in the event")
                  
                  booking_details = json.loads(event['body'])
                  
                  required_fields = ['email', 'room_id']
                  for field in required_fields:
                      if field not in booking_details:
                          raise ValueError(f"Missing required field: {field}")

                  # Generate a unique booking_id
                  booking_id = str(uuid.uuid4())

                  # Construct the booking details with generated booking_id
                  booking_details_with_id = {
                      'booking_id': booking_id,
                      'email': booking_details['email'],
                      'room_id': booking_details['room_id']
                  }

                  message_group_id = booking_details['room_id']
                  message_deduplication_id = hashlib.md5(json.dumps(booking_details_with_id).encode('utf-8')).hexdigest()

                  response = sqs.send_message(
                      QueueUrl=QUEUE_URL,
                      MessageBody=json.dumps(booking_details_with_id),
                      MessageGroupId=message_group_id,
                      MessageDeduplicationId=message_deduplication_id
                  )
                  return {
                      'statusCode': 200,
                        'isBase64Encoded': True,
                      'headers': {
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': '*',
                      'Access-Control-Allow-Methods': 'OPTIONS,POST',
                      
                      "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps({
                      'message': 'Booking details added to the queue',
                      'messageId': response['MessageId']
                      })
                  }
              except ValueError as ve:
                  return {
                      'statusCode': 400,
                        'isBase64Encoded': True,
                      'headers': {
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': '*',
                      'Access-Control-Allow-Methods': 'OPTIONS,POST',
                      "Access-Control-Allow-Credentials":  True
                      },
                      'body': json.dumps({
                          'error': str(ve)
                      })
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                        'isBase64Encoded': True,
                      'headers': {
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': '*',
                      'Access-Control-Allow-Methods': 'OPTIONS,POST',
                      "Access-Control-Allow-Credentials":  True   
                      },
                      'body': json.dumps({
                          'error': 'An error occurred',
                          'details': str(e)
                      })
                  }

      Runtime: python3.8
      Environment:
        Variables:
          QUEUE_URL: !Ref BookingQueue

  BookingValidationLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: BookingValidationLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime

          # Initialize boto3 clients
          dynamodb = boto3.resource('dynamodb')
          sns = boto3.client('sns')

          # Environment variables
          ROOMS_TABLE_NAME = os.environ['ROOMS_TABLE_NAME']
          BOOKINGS_TABLE_NAME = os.environ['BOOKINGS_TABLE_NAME']
          SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']

          def lambda_handler(event, context):
              rooms_table = dynamodb.Table(ROOMS_TABLE_NAME)
              bookings_table = dynamodb.Table(BOOKINGS_TABLE_NAME)
              
              for record in event['Records']:
                  try:
                      # Parse message body from SQS event
                      message = json.loads(record['body'])
                      
                      # Extract necessary information
                      booking_id = message['booking_id']
                      email = message['email']
                      room_id = message['room_id']
                      
                      # Check room availability in DynamoDB
                      response = rooms_table.get_item(
                          Key={'room': room_id}
                      )
                      
                      if 'Item' not in response or response['Item']['Availability'] != 'Available':
                          return {
                              'statusCode': 400,
                              'body': json.dumps({
                                  'error': f'Room {room_id} is not available.'
                              })
                          }
                      
                      # Update room availability to 'Not Available'
                      rooms_table.update_item(
                          Key={'room': room_id},
                          UpdateExpression="set Availability = :a",
                          ExpressionAttributeValues={':a': 'Not Available'}
                      )
                      
                      # Get current date
                      current_date = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
                      
                      # Add booking information to the bookings table
                      bookings_table.put_item(
                          Item={
                              'bookingid': booking_id,
                              'email': email,
                              'room_id': room_id,
                              'status': 'Confirmed',
                              'date': current_date
                          }
                      )
                      
                      # Construct SNS message
                      subject = "Booking Confirmation"
                      body_text = (f"Dear Customer,\n\n"
                                  f"Your booking for room {room_id} has been confirmed.\n"
                                  f"Booking ID: {booking_id}\n"
                                  f"Date: {current_date}\n\n"
                                  f"Thank you for choosing our service.\n")
                      
                      # Publish to SNS
                      sns.publish(
                          TopicArn=SNS_TOPIC_ARN,
                          Message=body_text,
                          Subject=subject,
                          MessageAttributes={
                              'email': {
                                  'DataType': 'String',
                                  'StringValue': email
                              }
                          }
                      )
                      
                  except Exception as e:
                      print(f"Error processing record: {record}")
                      print(f"Error message: {str(e)}")
                      return {
                          'statusCode': 500,
                          'body': json.dumps({
                              'error': 'An error occurred',
                              'details': str(e)
                          })
                      }
              
              return {
                  'statusCode': 200,
                  'body': json.dumps('Booking confirmation sent successfully.')
              }

      Runtime: python3.8
      Environment:
        Variables:
          ROOMS_TABLE_NAME: !Ref RoomsTable
          BOOKINGS_TABLE_NAME: !Ref BookingHistoryTable
          SNS_TOPIC_ARN: !Ref BookingNotificationsTopic

  AddRoomLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: AddRoomLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          # Initialize the DynamoDB resource
          dynamodb = boto3.resource('dynamodb')

          # Name of the DynamoDB table
          TABLE_NAME = 'rooms'

          def lambda_handler(event, context):
              try:
                  if 'body' not in event:
                      raise ValueError("Missing 'body' in the event")

                  room_details = json.loads(event['body'])

                  required_fields = ['agent', 'address', 'amenities', 'availability', 'beds', 'room', 'price']
                  for field in required_fields:
                      if field not in room_details:
                          raise ValueError(f"Missing required field: {field}")

                  agent = room_details['agent']
                  address = room_details['address']
                  amenities = room_details['amenities']
                  availability = room_details['availability']
                  beds = room_details['beds']
                  room = room_details['room']
                  price = room_details['price']

                  # Reference the DynamoDB table
                  table = dynamodb.Table(TABLE_NAME)

                  # Item to be inserted
                  item = {
                      'Agent': agent,
                      'Address': address,
                      'Amenities': amenities,
                      'Availability': availability,
                      'Beds': beds,
                      'room': room,
                      'Price': price
                  }

                  try:
                      # Put item into DynamoDB table
                      table.put_item(Item=item)
                      return {
                          'statusCode': 200,
                          'headers': {
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Headers': '*',
                              'Access-Control-Allow-Methods': 'OPTIONS,POST',
                              'Access-Control-Allow-Credentials': True
                          },
                          'body': json.dumps(f'Room {room} added successfully.')
                      }
                  except ClientError as e:
                      return {
                          'statusCode': 500,
                          'headers': {
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Headers': '*',
                              'Access-Control-Allow-Methods': 'OPTIONS,POST',
                              'Access-Control-Allow-Credentials': True
                          },
                          'body': json.dumps(f'Error adding room: {e.response["Error"]["Message"]}')
                      }
              except ValueError as ve:
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps({
                          'error': str(ve)
                      })
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps({
                          'error': 'An error occurred',
                          'details': str(e)
                      })
                  }
      Runtime: python3.8
      Environment:
        Variables:
          TABLE_NAME: !Ref RoomsTable

  UpdateRoomLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: UpdateRoomLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.exceptions import ClientError

          # Initialize the DynamoDB resource
          dynamodb = boto3.resource('dynamodb')

          # Name of the DynamoDB table
          TABLE_NAME = 'rooms'

          def lambda_handler(event, context):
              # Parse the body to get the input parameters
              try:
                  body = json.loads(event['body'])
                  room = body['room']
                  update_expression = []
                  expression_attribute_names = {}
                  expression_attribute_values = {}
                  
                  if 'agent' in body:
                      update_expression.append("#a = :agent")
                      expression_attribute_names['#a'] = "Agent"
                      expression_attribute_values[':agent'] = body['agent']
                  
                  if 'address' in body:
                      update_expression.append("#ad = :address")
                      expression_attribute_names['#ad'] = "Address"
                      expression_attribute_values[':address'] = body['address']
                  
                  if 'amenities' in body:
                      update_expression.append("#am = :amenities")
                      expression_attribute_names['#am'] = "Amenities"
                      expression_attribute_values[':amenities'] = body['amenities']
                  
                  if 'availability' in body:
                      update_expression.append("#av = :availability")
                      expression_attribute_names['#av'] = "Availability"
                      expression_attribute_values[':availability'] = body['availability']
                  
                  if 'beds' in body:
                      update_expression.append("#b = :beds")
                      expression_attribute_names['#b'] = "Beds"
                      expression_attribute_values[':beds'] = body['beds']
                  
                  if 'price' in body:
                      update_expression.append("#p = :price")
                      expression_attribute_names['#p'] = "Price"
                      expression_attribute_values[':price'] = body['price']
                  
                  if not update_expression:
                      return {
                          'statusCode': 400,
                          'headers': {
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Headers': '*',
                              'Access-Control-Allow-Methods': 'OPTIONS,POST',
                              'Access-Control-Allow-Credentials': True
                          },
                          'body': json.dumps('No fields to update.')
                      }

                  update_expression = "SET " + ", ".join(update_expression)
              except KeyError as e:
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps(f'Missing parameter: {e}')
                  }
              except json.JSONDecodeError:
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps('Invalid JSON in body.')
                  }

              # Reference the DynamoDB table
              table = dynamodb.Table(TABLE_NAME)

              try:
                  # Update item in DynamoDB table
                  response = table.update_item(
                      Key={
                          'room': room
                      },
                      UpdateExpression=update_expression,
                      ExpressionAttributeNames=expression_attribute_names,
                      ExpressionAttributeValues=expression_attribute_values,
                      ReturnValues="UPDATED_NEW",
                      ConditionExpression="attribute_exists(room)"
                  )
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps(f'Room {room} updated successfully. {response["Attributes"]}')
                  }
              except ClientError as e:
                  if e.response['Error']['Code'] == 'ConditionalCheckFailedException':
                      return {
                          'statusCode': 404,
                          'headers': {
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Headers': '*',
                              'Access-Control-Allow-Methods': 'OPTIONS,POST',
                              'Access-Control-Allow-Credentials': True
                          },
                          'body': json.dumps(f'Room {room} not found.')
                      }
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps(f'Error updating room: {e.response["Error"]["Message"]}')
                  }
      Runtime: python3.8
      Environment:
        Variables:
          TABLE_NAME: !Ref RoomsTable

  DeleteRoomLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: DeleteRoomLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.exceptions import ClientError

          # Initialize the DynamoDB resource
          dynamodb = boto3.resource('dynamodb')

          # Name of the DynamoDB table
          TABLE_NAME = 'rooms'

          def lambda_handler(event, context):
              # Parse the body to get the input parameters
              try:
                  body = json.loads(event['body'])
                  agent = body['agent']
                  room = body['room']
              except KeyError as e:
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps(f'Missing parameter: {e}')
                  }
              except json.JSONDecodeError:
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps('Invalid JSON in body.')
                  }

              # Reference the DynamoDB table
              table = dynamodb.Table(TABLE_NAME)

              try:
                  # Delete item from DynamoDB table
                  response = table.delete_item(
                      Key={
                          'room': room
                      }
                  )
                  if 'Attributes' in response:
                      return {
                          'statusCode': 200,
                          'headers': {
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Headers': '*',
                              'Access-Control-Allow-Methods': 'OPTIONS,POST',
                              "Access-Control-Allow-Credentials": True
                          },
                          'body': json.dumps(f'Room {room} removed successfully.')
                      }
                  else:
                      return {
                          'statusCode': 404,
                          'headers': {
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Headers': '*',
                              'Access-Control-Allow-Methods': 'OPTIONS,POST',
                              "Access-Control-Allow-Credentials": True
                          },
                          'body': json.dumps(f'Room {room} not found.')
                      }
              except ClientError as e:
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps(f'Error removing room: {e.response["Error"]["Message"]}')
          }
      Runtime: python3.8
      Environment:
        Variables:
          TABLE_NAME: !Ref RoomsTable

  EmailNotificationLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: EmailNotificationLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          # Initialize the SNS client
          sns = boto3.client('sns')

          # Environment variable for the SNS topic ARN
          SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']

          def lambda_handler(event, context):
              try:
                  # Parse input parameters
                  email = event.get('email')
                  message = event.get('message')
                  
                  if not email or not message:
                      raise ValueError("Missing required parameters: 'email' and 'message'")
                  
                  # Construct the SNS message
                  sns_message = {
                      'default': message
                  }
                  
                  # Publish the message to the SNS topic
                  response = sns.publish(
                      TopicArn=SNS_TOPIC_ARN,
                      Message=json.dumps(sns_message),
                      Subject="Notification",
                      MessageStructure='json',
                      MessageAttributes={
                          'email': {
                              'DataType': 'String',
                              'StringValue': email
                          }
                      }
                  )
                  
                  return {
                      'statusCode': 200,
                      'isBase64Encoded': False,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps({
                          'message': 'Notification sent successfully',
                          'messageId': response['MessageId']
                      })
                  }
              
              except ValueError as ve:
                  return {
                      'statusCode': 400,
                      'isBase64Encoded': False,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps({
                          'error': str(ve)
                      })
                  }
              
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'isBase64Encoded': False,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps({
                          'error': 'An error occurred',
                          'details': str(e)
                      })
                  }
      Runtime: python3.8
      Environment:
        Variables:
          SNS_TOPIC_ARN: !Ref BookingNotificationsTopic

  AvailableRoomsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: AvailableRoomsLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.exceptions import ClientError
          from decimal import Decimal

          dynamodb = boto3.resource('dynamodb')
          TABLE_NAME = 'rooms'

          # Custom encoder to convert Decimal to float
          class DecimalEncoder(json.JSONEncoder):
              def default(self, obj):
                  if isinstance(obj, Decimal):
                      return float(obj)
                  return super(DecimalEncoder, self).default(obj)

          def lambda_handler(event, context):
              table = dynamodb.Table(TABLE_NAME)
              all_rooms = []
              last_evaluated_key = None

              try:
                  while True:
                      if last_evaluated_key:
                          response = table.scan(
                              ExclusiveStartKey=last_evaluated_key
                          )
                      else:
                          response = table.scan()
                      
                      scanned_items = response.get('Items', [])
                      print(f'Scanned {len(scanned_items)} items')
                      all_rooms.extend(scanned_items)
                      last_evaluated_key = response.get('LastEvaluatedKey')
                      
                      if not last_evaluated_key:
                          break

                  print(f'Total rooms: {len(all_rooms)}')

                  return {
                      'statusCode': 200,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,GET',
                          "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps({'rooms': all_rooms}, cls=DecimalEncoder)
                  }
              except ClientError as e:
                  print(f'ClientError: {e.response["Error"]["Message"]}')
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,GET',
                          "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps(f'Error fetching rooms: {e.response["Error"]["Message"]}')
                  }
              except Exception as e:
                  print(f'Exception: {str(e)}')
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,GET',
                          "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps(f'Error: {str(e)}')
                  }
      Runtime: python3.8
      Environment:
        Variables:
          TABLE_NAME: !Ref RoomsTable

  GetRoomLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: GetRoomLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.exceptions import ClientError
          from decimal import Decimal

          dynamodb = boto3.resource('dynamodb')
          TABLE_NAME = 'rooms'

          # Custom encoder to convert Decimal to float
          class DecimalEncoder(json.JSONEncoder):
              def default(self, obj):
                  if isinstance(obj, Decimal):
                      return float(obj)
                  return super(DecimalEncoder, self).default(obj)

          def lambda_handler(event, context):
              try:
                  body = json.loads(event['body'])
                  agent = body['agent']
              except (KeyError, json.JSONDecodeError):
                  return {
                      'statusCode': 400,
                      'body': json.dumps('Missing or invalid required parameter: agent'),
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,GET',
                          "Access-Control-Allow-Credentials": True
                      }
                  }

              table = dynamodb.Table(TABLE_NAME)

              try:
                  response = table.scan(
                      FilterExpression='#agent = :agent',
                      ExpressionAttributeNames={'#agent': 'Agent'},
                      ExpressionAttributeValues={':agent': agent}
                  )
                  rooms = response.get('Items', [])

                  return {
                      'statusCode': 200,
                      'body': json.dumps({'rooms': rooms}, cls=DecimalEncoder),
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,GET',
                          "Access-Control-Allow-Credentials": True
                      }
                  }
              except ClientError as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error fetching rooms: {e.response["Error"]["Message"]}'),
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,GET',
                          "Access-Control-Allow-Credentials": True
                      }
                  }
      Runtime: python3.8
      Environment:
        Variables:
          TABLE_NAME: !Ref RoomsTable

  RoomNumberLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: RoomNumberLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.exceptions import ClientError
          from decimal import Decimal

          dynamodb = boto3.resource('dynamodb')
          TABLE_NAME = 'rooms'

          # Custom encoder to convert Decimal to float
          class DecimalEncoder(json.JSONEncoder):
              def default(self, obj):
                  if isinstance(obj, Decimal):
                      return float(obj)
                  return super(DecimalEncoder, self).default(obj)

          def lambda_handler(event, context):
              try:
                  # Parse input parameters
                  body = json.loads(event['body'])
                  room_number = body['room']
              except (KeyError, json.JSONDecodeError):
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps('Missing or invalid input parameters.')
                  }

              # Reference the DynamoDB table
              table = dynamodb.Table(TABLE_NAME)

              try:
                  # Get item from DynamoDB table
                  response = table.get_item(
                      Key={'room': room_number}
                  )

                  if 'Item' in response:
                      return {
                          'statusCode': 200,
                          'headers': {
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Headers': '*',
                              'Access-Control-Allow-Methods': 'OPTIONS,POST',
                              "Access-Control-Allow-Credentials": True
                          },
                          'body': json.dumps(response['Item'], cls=DecimalEncoder)
                      }
                  else:
                      return {
                          'statusCode': 404,
                          'headers': {
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Headers': '*',
                              'Access-Control-Allow-Methods': 'OPTIONS,POST',
                              "Access-Control-Allow-Credentials": True
                          },
                          'body': json.dumps(f'Room {room_number} not found.')
                      }
              except ClientError as e:
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps(f'Error getting room: {e.response["Error"]["Message"]}')
                  }
      Runtime: python3.8
      Environment:
        Variables:
          TABLE_NAME: !Ref RoomsTable

  GetUserBookingLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: GetUserBookingLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.exceptions import ClientError
          from decimal import Decimal

          dynamodb = boto3.resource('dynamodb')
          TABLE_NAME = 'booking'

          # Custom encoder to convert Decimal to float
          class DecimalEncoder(json.JSONEncoder):
              def default(self, obj):
                  if isinstance(obj, Decimal):
                      return float(obj)
                  return super(DecimalEncoder, self).default(obj)

          def lambda_handler(event, context):
              try:
                  # Parse input parameters
                  body = json.loads(event['body'])
                  email = body['email']
              except (KeyError, json.JSONDecodeError):
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps('Missing or invalid input parameters.')
                  }

              table = dynamodb.Table(TABLE_NAME)
              bookings = []
              last_evaluated_key = None

              try:
                  while True:
                      if last_evaluated_key:
                          response = table.scan(
                              FilterExpression='#email = :email',
                              ExpressionAttributeNames={'#email': 'email'},
                              ExpressionAttributeValues={':email': email},
                              ExclusiveStartKey=last_evaluated_key
                          )
                      else:
                          response = table.scan(
                              FilterExpression='#email = :email',
                              ExpressionAttributeNames={'#email': 'email'},
                              ExpressionAttributeValues={':email': email}
                          )
                      
                      scanned_items = response.get('Items', [])
                      print(f'Scanned {len(scanned_items)} items')
                      bookings.extend(scanned_items)
                      last_evaluated_key = response.get('LastEvaluatedKey')
                      
                      if not last_evaluated_key:
                          break

                  print(f'Total bookings for {email}: {len(bookings)}')

                  return {
                      'statusCode': 200,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps({'bookings': bookings}, cls=DecimalEncoder)
                  }
              except ClientError as e:
                  print(f'ClientError: {e.response["Error"]["Message"]}')
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps(f'Error fetching bookings: {e.response["Error"]["Message"]}')
                  }
              except Exception as e:
                  print(f'Exception: {str(e)}')
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          "Access-Control-Allow-Credentials": True
                      },
                      'body': json.dumps(f'Error: {str(e)}')
                  }
      Runtime: python3.8
      Environment:
        Variables:
          TABLE_NAME: !Ref BookingHistoryTable

  # API Gateway
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: DALVacationHomeApi

  # Resources
  AuthResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: auth
      RestApiId: !Ref ApiGateway

  BookingRequest:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: booking
      RestApiId: !Ref ApiGateway

  BookingVaidationResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: booking-validate
      RestApiId: !Ref ApiGateway

  RoomResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: room
      RestApiId: !Ref ApiGateway

  RoomAddResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: room-add
      RestApiId: !Ref ApiGateway

  RoomUpdateResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: room-update
      RestApiId: !Ref ApiGateway

  RoomDeleteResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: room-delete
      RestApiId: !Ref ApiGateway

  RoomGetResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: room-get
      RestApiId: !Ref ApiGateway

  RoomNumberResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: room-number
      RestApiId: !Ref ApiGateway

  AvailableRoomsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: rooms-available
      RestApiId: !Ref ApiGateway

  GetUserBookingResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: booking-user
      RestApiId: !Ref ApiGateway

  # Methods for /booking
  BookingMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      ResourceId: !Ref BookingRequest
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${BookingRequestLambdaArn}/invocations
          - BookingRequestLambdaArn: !GetAtt BookingRequestLambda.Arn

  # BookingMethodOptions:
  #   Type: AWS::ApiGateway::Method
  #   Properties:
  #     Authorithod: OPTIONS
  #     ResourceId: !Ref
  #     RestApiId: !RezationType: NONE
  #     HttpMef ApiGateway
  #     Integration:
  #       IntegrationResponses:
  #         - StatusCode: 200
  #           ResponseParameters:
  #             method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
  #             method.response.header.Access-Control-Allow-Origin: "'*'"
  #             method.response.header.Access-Control-Allow-Methods: "'OPTIONS,POST'"
  #       RequestTemplates:
  #         application/json: '{"statusCode": 200}'
  #       PassthroughBehavior: WHEN_NO_MATCH
  #       Type: MOCK
  #     MethodResponses:
  #       - StatusCode: 200
  #         ResponseParameters:
  #           method.response.header.Access-Control-Allow-Headers: true
  #           method.response.header.Access-Control-Allow-Methods: true
  #           method.response.header.Access-Control-Allow-Origin: true

  ValidationMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      ResourceId: !Ref BookingVaidationResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${BookingValidationLambdaArn}/invocations
          - BookingValidationLambdaArn: !GetAtt BookingValidationLambda.Arn

  # Methods for /room
  AddRoomMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      ResourceId: !Ref RoomAddResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AddRoomLambdaArn}/invocations
          - AddRoomLambdaArn: !GetAtt AddRoomLambda.Arn

  UpdateRoomMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      ResourceId: !Ref RoomResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: PUT
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${UpdateRoomLambdaArn}/invocations
          - UpdateRoomLambdaArn: !GetAtt UpdateRoomLambda.Arn

  DeleteRoomMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      ResourceId: !Ref RoomUpdateResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: DELETE
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DeleteRoomLambdaArn}/invocations
          - DeleteRoomLambdaArn: !GetAtt DeleteRoomLambda.Arn

  GetRoomMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      ResourceId: !Ref RoomGetResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetRoomLambdaArn}/invocations
          - GetRoomLambdaArn: !GetAtt GetRoomLambda.Arn

  RoomNumberMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      ResourceId: !Ref RoomNumberResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RoomNumberLambdaArn}/invocations
          - RoomNumberLambdaArn: !GetAtt RoomNumberLambda.Arn

  AvailableRoomsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: GET
      ResourceId: !Ref AvailableRoomsResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: GET
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AvailableRoomsLambdaArn}/invocations
          - AvailableRoomsLambdaArn: !GetAtt AvailableRoomsLambda.Arn

  GetUserBookingMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      ResourceId: !Ref GetUserBookingResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetUserBookingLambdaArn}/invocations
          - GetUserBookingLambdaArn: !GetAtt GetUserBookingLambda.Arn

  EmailNotificationMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      ResourceId: !Ref AuthResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${EmailNotificationLambdaArn}/invocations
          - EmailNotificationLambdaArn: !GetAtt EmailNotificationLambda.Arn

Outputs:
  ApiGatewayUrl:
    Description: URL of the API Gateway
    Value: !Sub "https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod/"
  BookingQueueUrl:
    Description: URL of the Booking SQS Queue
    Value: !Ref BookingQueue
  RoomsTableName:
    Description: Name of the Rooms DynamoDB Table
    Value: !Ref RoomsTable
  BookingHistoryTableName:
    Description: Name of the Booking History DynamoDB Table
    Value: !Ref BookingHistoryTable
  BookingRequestLambdaArn:
    Description: ARN of the Booking Request Lambda Function
    Value: !GetAtt BookingRequestLambda.Arn
  BookingValidationLambdaArn:
    Description: ARN of the Booking Validation Lambda Function
    Value: !GetAtt BookingValidationLambda.Arn
  AddRoomLambdaArn:
    Description: ARN of the Add Room Lambda Function
    Value: !GetAtt AddRoomLambda.Arn
  UpdateRoomLambdaArn:
    Description: ARN of the Update Room Lambda Function
    Value: !GetAtt UpdateRoomLambda.Arn
  DeleteRoomLambdaArn:
    Description: ARN of the Delete Room Lambda Function
    Value: !GetAtt DeleteRoomLambda.Arn
  EmailNotificationLambdaArn:
    Description: ARN of the Email Notification Lambda Function
    Value: !GetAtt EmailNotificationLambda.Arn
  AvailableRoomsLambdaArn:
    Description: ARN of the Available Rooms Lambda Function
    Value: !GetAtt AvailableRoomsLambda.Arn
  GetRoomLambdaArn:
    Description: ARN of the Get Room Lambda Function
    Value: !GetAtt GetRoomLambda.Arn
  RoomNumberLambdaArn:
    Description: ARN of the Room Number Lambda Function
    Value: !GetAtt RoomNumberLambda.Arn
  GetUserBookingLambdaArn:
    Description: ARN of the Get User Booking Lambda Function
    Value: !GetAtt GetUserBookingLambda.Arn
